\> Problem: [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/)

[TOC]



### 思路

> 解题思路

> 拿到题目的时候，没有思路改怎么去处理；
>
> ==使用栈去模拟入栈和出栈序列来进行判定==
>
> 按照入栈序列 和出栈序列进行的话，【如果出栈序列是正确的】最后栈中的一定是没有元素的【入栈和出栈结果确定且正确的话，只能有一种操作方式可以实现这种序列】，所以使用一个栈来进行模拟这个过程
>
> 遍历入栈序列，逐个将入栈序列插入栈中的同时，挨个比较出栈的值，如果出栈的值等于栈顶的元素，则表明在出栈序列执行完成之后，这个值是要出栈的，所以直接出栈该值然后在进行比较下一个出栈序列值，直至栈为空或者两个序列遍历完毕

###  解题方法

> 解题方法

> 1. ​    // 这个题目 使用一个栈来先进行模拟入栈，使用入栈的序列进行入栈操作
>
>    ​    // 同时将入栈的元素与出栈序列的第i个值进行比较，如果相等的话，则模拟出栈操作
>
>    ​    // 直至出栈操作结束或者入栈序列为空时候，进行判定，如果两个栈都为空的话，
>
>    ​    // 说明出栈序列是对的，否则是错误的出栈序列

###  复杂度

#### 时间复杂度: 

> 时间复杂度： $O(n$)
>

#### 空间复杂度: 

> 空间复杂度： $O(n)$



###  Code

```Java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        // 这个题目 使用一个栈来先进行模拟入栈，使用入栈的序列进行入栈操作
        // 同时将入栈的元素与出栈序列的第i个值进行比较，如果相等的话，则模拟出栈操作
        // 直至出栈操作结束或者入栈序列为空时候，进行判定，如果两个栈都为空的话，
        // 说明出栈序列是对的，否则是错误的出栈序列

        if(pushed==null|| popped.length){
            return true;
        }
        Stack<Integer> stack = new Stack<>();
        int j=0;
        for(int i =0; i<pushed.length; i++){
            stack.push(pushed[i]);//将数据压入到栈中
            while(!stack.isEmpty()&&stack.peek()==popped[j]){
                stack.pop();
                j++;
            }
        }
        return stack.isEmpty();

    }
}
```

> 在使用for 循环和 while循环的时候，先逐个遍历入栈序列，在入栈的同时，用while循环比较出栈值与栈顶元素，若相等则模拟出栈操作，直至两个序列遍历完毕，最后验证栈为空

```java
while(!stack.isEmpty()&&stack.peek()==popped[j]) 
    // 这个while  序列需要注意，使用的是短路&&，因为要先保证调用栈的peek()函数的时候，栈不能为空，否则会报错，所以要先保证栈内有数据，然后在进行比较
    // 栈为空的时候 可能第一个插入的数据是2 然后在出栈序列里边第一个序列也是2  然后就把2 弹出了，然后在while循环的时候，栈空了，就会报错，所以要判读
    
    // 另外是比较栈顶的元素 而不是只比较 新插入的元素pushed[i] 自己一开始编码的时候就弄错了 如果这样写的话会导致 栈内之前插入的数据被忽略
```

